---
layout: post
title:  "Building hsdis in 2022"
date:   2022-04-30 14:14:42 +0100
categories: hsdis
---

Note: this post is a not very serious guide to building `hsdis` using a custom `cmake` build script, in order to avoid having to set up an environment for the openjdk build system on Windows (though I've also tested that the script works under WSL Linux). If your're looking for official instructions to builds `hsdis` they can be found in the openjdk repo here: [https://github.com/openjdk/jdk/tree/master/src/utils/hsdis](https://github.com/openjdk/jdk/tree/master/src/utils/hsdis).

## What is hsdis?

`hsdis` is a disassembler plugin for the OpenJDK/HotSpot JVM. It can be used in conjunction with the `PrintAssembly` option (ass well as other options) to disassemble and print out code generated by HotSpot's JIT compilers. It is a separate shared library that can be installed on the `PATH` or in the JDK directory next to (lib)jvm.(dll/so/dylib). The VM will dynamically load this library and call the function it exposes to disassemble dynamically generated code.

If you're interested in the code generated by the VM, you will need the `hsdis` plugin to make it visible in a human-readable format (well, if that human happens to know how to read assembly). Without the plugin, the `PrintAssembly` option will just output the bytes of the instructions instead.

## Building hsdis

Not too long ago, the `hsdis` plugin required binutils as a dependency. Fairly recently however, 2 more flavours of `hsdis` were added, one based on llvm, and one based on the capstone disassembler library. It is this latter flavour that makes it significantly easier to build `hsdis`.

The official way to build `hsdis` is through the openjdk build system. If you're interested in that, the instructions can be found [here](https://github.com/openjdk/jdk/tree/master/src/utils/hsdis).

There is, however, an easier way to build it that, crucially for Windows users, doesn't require setting up cygwin or WSL and using autoconf and `make` to run the openjdk build system.

Users also need to provide the capstone library for the build process, a project that uses `cmake` as a build system (well, 'build system generator').

With the method I'm about to show, we just need to have `cmake` and a C compiler installed, and then we can use a simple cmake file to build both capstone and `hsdis` in one shot (with capstone statically linked into `hsdis`).

First, we clone the openjdk/jdk repo from github, which contains the `hsdis` source code:

```sh
git clone https://github.com/openjdk/jdk.git
```

Note that even though this will give us the latests version of the source code, the produced library will work with HotSpot from JDK 8 and later.

Then, navigate to the `src/utils/hsdis/capstone` directory, which contains the source code for the capstone based `hsdis`.

Create a new file called `CMakeLists.txt` (a `cmake` build file) and put the following inside:

```cmake
cmake_minimum_required(VERSION 3.15)
project(hsdis)

add_library(hsdis SHARED ${CMAKE_CURRENT_LIST_DIR}/hsdis-capstone.c)

include(FetchContent)

message(STATUS "Fetching capstone (next)...")
FetchContent_Declare(
	capstone
	GIT_REPOSITORY
		https://github.com/capstone-engine/capstone
	GIT_TAG
		next
)
set(CMAKE_POSITION_INDEPENDENT_CODE ON) # needed for linux
set(CAPSTONE_ARCHITECTURE_DEFAULT OFF)
set(CAPSTONE_X86_SUPPORT ON)
FetchContent_MakeAvailable(capstone)

target_link_libraries(hsdis PRIVATE capstone::capstone)
target_include_directories(hsdis PUBLIC ${CMAKE_CURRENT_LIST_DIR}/..)
target_compile_definitions(hsdis
  PRIVATE 
    CAPSTONE_ARCH=CS_ARCH_X86
	CAPSTONE_MODE=CS_MODE_64)
set_target_properties(hsdis PROPERTIES OUTPUT_NAME hsdis-amd64)
set_target_properties(hsdis PROPERTIES PREFIX "")

install(TARGETS hsdis)
```

At this point it's important to note that this build script is for building `hsdis` for the x86_64 architecture. We only enable x86 support in capstone with the `CAPSTONE_X86_SUPPORT` flag, and the `-amd64` suffix of the library name is what HotSpot will look for on x64 systems.

This script will automatically fetch the capstone source repository (the `next` branch) from github and build it, using the `FetchContent` functions.

We link against capstone with `target_link_libraries`.

We also include the parent directory as an include directory with `target_include_directories`, since it contains the `hsdis.h` header file.

Lastly, we set the `CAPSTONE_ARCH` and `CAPSTONE_MODE` preprocessor defines with `target_compile_definitions` which end up being passed to capstone at runtime.

Then, to build `hsdis` I use the following commands:

```sh
cmake -B build <extra cmake config flags>
```

This command will create a `build` directory for the build files. Since I'm using Visual Studio I pass the extra flags `-A x64` and `-T host=x64` to select the x64 architecture and toolchain. On Linux with `gcc` or `cc` no extra flags are needed.

```sh
cmake --build build --config Release
```

This builds the library.

```sh
cmake --install build --prefix install
```

This installs the library and debug symbol file in the `install` directory.

If everything went well, this will have created the `hsdis-amd64.dll` file under `install/bin`. This file can now be copied into the `bin/server` directory in a JDK to enable disassembling. Though, what I've done is create an `hsdis` folder somewhere on my PC, plopped the `.dll` file in there, and put that folder on my `PATH`. HotSpot will be able to pick it up from there.

## Testing it out

To test out the library we built, I create a simple java class that can be used to JIT compile a payload method for which we want to see the assembly.

```java
public class Main {
    public static void main(String[] args) {
        for (int i = 0; i < 20_000; i++) {
            add(42, 42);
        }
    }

    private static int add(int a, int b) {
        return a + b;
    }
}
```

Then I run the following commands to print the assembly for the `add` method:

```sh
javac Main.java
java -Xbatch '-XX:-TieredCompilation' '-XX:CompileCommand=dontinline,Main::add*' '-XX:CompileCommand=PrintAssembly,Main::add*' Main
```

- `-Xbatch` blocks execution until the JIT finishes, so we can get our assembly before the program exits.
- `'-XX:-TieredCompilation'` disables the C1 JIT compiler, so we get a somewhat reduced output. The C2 output is usually what's interesting, as that is the most optimized.
- `'-XX:CompileCommand=dontinline,Main::add*'` disable inlining of the `add` method, so that we get a clean compilation of that method without it being inlined into the loop, and also so that the JIT doesn't know that the return value is not actually being used.
- `'-XX:CompileCommand=PrintAssembly,Main::add*'` print out the assembly for the `add` method.
- Note that I've also used to quotes `'` so that powershell doesn't try to interpret the arguments as script syntax.

And BOOM, assembly:

```text
============================= C2-compiled nmethod ==============================
----------------------------------- Assembly -----------------------------------

Compiled method (c2)      58   13             Main::add (4 bytes)
 total in heap  [0x000001f699c13610,0x000001f699c13810] = 512
 relocation     [0x000001f699c13768,0x000001f699c13778] = 16
 main code      [0x000001f699c13780,0x000001f699c137c0] = 64
 stub code      [0x000001f699c137c0,0x000001f699c137d8] = 24
 oops           [0x000001f699c137d8,0x000001f699c137e0] = 8
 scopes data    [0x000001f699c137e0,0x000001f699c137e8] = 8
 scopes pcs     [0x000001f699c137e8,0x000001f699c13808] = 32
 dependencies   [0x000001f699c13808,0x000001f699c13810] = 8

[Disassembly]
--------------------------------------------------------------------------------
[Constant Pool (empty)]

--------------------------------------------------------------------------------

[Verified Entry Point]
  # {method} {0x000001f6a94002d8} 'add' '(II)I' in 'Main'
  # parm0:    rdx       = int
  # parm1:    r8        = int
  #           [sp+0x20]  (sp of caller)
  0x000001f699c13780:   subq            $0x18, %rsp
  0x000001f699c13787:   movq            %rbp, 0x10(%rsp)
  0x000001f699c1378c:   movl            %edx, %eax
  0x000001f699c1378e:   addl            %r8d, %eax
  0x000001f699c13791:   addq            $0x10, %rsp
  0x000001f699c13795:   popq            %rbp
  0x000001f699c13796:   cmpq            0x338(%r15), %rsp   ;   {poll_return}
  0x000001f699c1379d:   ja              0x1f699c137a4
  0x000001f699c137a3:   retq
  0x000001f699c137a4:   movabsq         $0x1f699c13796, %r10;   {internal_word}
  0x000001f699c137ae:   movq            %r10, 0x350(%r15)
  0x000001f699c137b5:   jmp             0x1f699bf3400       ;   {runtime_call SafepointBlob}
  0x000001f699c137ba:   hlt
  0x000001f699c137bb:   hlt
  0x000001f699c137bc:   hlt
  0x000001f699c137bd:   hlt
  0x000001f699c137be:   hlt
  0x000001f699c137bf:   hlt
[Exception Handler]
  0x000001f699c137c0:   jmp             0x1f699c09580       ;   {no_reloc}
[Deopt Handler Code]
  0x000001f699c137c5:   callq           0x1f699c137ca
  0x000001f699c137ca:   subq            $5, (%rsp)
  0x000001f699c137cf:   jmp             0x1f699bf26a0       ;   {runtime_call DeoptimizationBlob}
  0x000001f699c137d4:   hlt
  0x000001f699c137d5:   hlt
  0x000001f699c137d6:   hlt
  0x000001f699c137d7:   hlt
--------------------------------------------------------------------------------
[/Disassembly]
```

Now, all that's left is learning to interpret this ;)

## Thanks for reading
